namespace Reloaded.Mod.Loader.Update.Packs;

/// <summary>
/// Utility class for automatic creation of packages based on a given sample input of mods.
/// </summary>
public static class AutoPackCreator
{
    /// <summary>
    /// Checks if all mods in given list can be used in the pack by verifying they have enabled updates.
    /// </summary>
    /// <param name="configurations">List of mod configurations to check.</param>
    /// <param name="incompatibleMods">List of mods to check for compatibility.</param>
    /// <returns>True if mods can be packed, else false.</returns>
    public static bool ValidateCanCreate(IEnumerable<PathTuple<ModConfig>> configurations, out List<PathTuple<ModConfig>> incompatibleMods)
    {
        incompatibleMods = new List<PathTuple<ModConfig>>();
        foreach (var config in configurations)
        {
            if (!PackageResolverFactory.HasAnyConfiguredResolver(config))
                incompatibleMods.Add(config);
        }

        return incompatibleMods.Count <= 0;
    }

    /// <summary>
    /// Automatically creates a package.
    /// </summary>
    /// <param name="configurations">The configurations used to create the config. Must at least have update data, ModId and ModName.</param>
    /// <param name="imageConverter">Used for converting images.</param>
    /// <param name="packageProviders">Providers that can be used to search for packages.</param>
    /// <param name="token">Token to cancel the operation.</param>
    public static async Task<ReloadedPackBuilder> CreateAsync(IEnumerable<ModConfig> configurations, IImageConverter imageConverter, IList<IDownloadablePackageProvider> packageProviders, CancellationToken token = default)
    {
        var builder = new ReloadedPackBuilder();
        var imageDownloader = new ImageCacheService();
        
        builder.SetName("My Autogenerated Package");
        builder.SetReadme("You should probably add description here.");

        foreach (var config in configurations)
        {
            var itemBuilder = builder.AddModItem(config.ModId);
            itemBuilder.SetName(config.ModName);
            itemBuilder.SetPluginData(config.PluginData);

            var bestPkg = await GetBestPackageForTemplateAsync(config.ModId, config.ModName, packageProviders, token);
            
            // Add images if possible
            if (bestPkg.images != null)
            {
                foreach (var image in bestPkg.images)
                {
                    var file = await imageDownloader.GetOrDownloadFileFromUrl(image.Uri, imageDownloader.ModPreviewExpiration, false, token);
                    var converted = imageConverter.Convert(file, Path.GetExtension(image.Uri.ToString()), out string ext);
                    itemBuilder.AddImage(converted, ext, image.Caption);
                }
            }
                
            // Add readme if possible
            if (!string.IsNullOrEmpty(bestPkg.markdownReadme))
                itemBuilder.SetReadme(bestPkg.markdownReadme);
        }
        
        return builder;
    }

    private static async Task<(DownloadableImage[]? images, string markdownReadme)> GetBestPackageForTemplateAsync(string modId, string modName,
        IList<IDownloadablePackageProvider> downloadablePackageProviders, CancellationToken cancellationToken)
    {
        (DownloadableImage[]? images, string markdownReadme) result = new();
        
        // We will get all packages with highest version and copy images & readme down the road.
        NuGetVersion? highestVersion = null;
        List<IDownloadablePackage> itemsForHighestVersion = new List<IDownloadablePackage>();

        // Note: Some sources don't support e.g. images.
        // We prioritise sources based on whether they contain images, then by readme.
        // If preferred source does not contain both readme and image, we stitch them together from sources that do.
        foreach (var provider in downloadablePackageProviders)
        {
            // Override if better than current best.
            var candidates = await provider.SearchForModAsync(modId, modName, 50, 4, true, cancellationToken);
            foreach (var candidate in candidates)
            {
                // Find items for highest version
                if (candidate.Version != null)
                {
                    if (highestVersion == null)
                        highestVersion = candidate.Version;

                    if (candidate.Version == highestVersion)
                        itemsForHighestVersion.Add(candidate);

                    if (candidate.Version > highestVersion)
                    {
                        itemsForHighestVersion.Clear();
                        highestVersion = candidate.Version;
                        itemsForHighestVersion.Add(candidate);
                    }
                }
                
                // Set images if more than existing best result.
                if (candidate.Images != null)
                {
                    // Assign images if unassigned
                    result.images ??= candidate.Images;

                    // Prefer source with more images.
                    if (candidate.Images.Length > result.images.Length)
                        result.images = candidate.Images;
                }
                    
                // Set description if unassigned.
                if (candidate.MarkdownReadme != null)
                    result.markdownReadme ??= candidate.MarkdownReadme;
            }
        }
        
        // Override supported items from 
        foreach (var item in itemsForHighestVersion)
        {
            // Set description if unassigned.
            if (item.MarkdownReadme != null)
                result.markdownReadme = item.MarkdownReadme;
         
            // Set images to ones from newest version in case older version had more images.
            // But only if more than 1 image. We want to filter out entries with only thumbnail.
            if (item.Images is { Length: > 1 })
                result.images = item.Images;
        }
        
        return result;
    }
}